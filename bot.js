// import { Telegraf } from "telegraf";
// import RunwayML from "@runwayml/sdk";
// import axios from "axios";
// import fs from "fs";
// import path from "path";
// import dotenv from "dotenv";

// // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env
// dotenv.config();

// // ----- –ù–ê–°–¢–†–û–ô–ö–ò -----------------------------------------------------------
// const BOT_TOKEN = process.env.BOT_TOKEN;           // —Ç–æ–∫–µ–Ω –æ—Ç @BotFather
// const RUNWAY_API_KEY = process.env.RUNWAY_API_KEY; // –∫–ª—é—á Runway ML
// const RUNWAY_VERSION = "2024-11-06";              // –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è API
// const TMP_DIR = path.resolve("./images");         // –∫—É–¥–∞ –∫–ª–∞–¥—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–æ—Ç–æ

// if (!fs.existsSync(TMP_DIR)) fs.mkdirSync(TMP_DIR);

// // ---------------------------------------------------------------------------
// const bot = new Telegraf(BOT_TOKEN);

// // –ö–ª–∏–µ–Ω—Ç Runway SDK
// const runway = new RunwayML({
//   apiKey: RUNWAY_API_KEY,
//   headers: { "X-Runway-Version": RUNWAY_VERSION },
// });

// // –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ prompt –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
// const userPrompts = new Map();

// // 1) –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç-–æ–ø–∏—Å–∞–Ω–∏–µ
// bot.on("text", async (ctx) => {
//   userPrompts.set(ctx.chat.id, ctx.message.text);
//   await ctx.reply("–¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –≤–∏–¥–µ–æ.");
// });

// // 2) –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ç–æ ‚Üí –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤–∏–¥–µ–æ
// bot.on("photo", async (ctx) => {
//   const prompt = userPrompts.get(ctx.chat.id);
//   if (!prompt) {
//     return ctx.reply("–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å —Ç–µ–∫—Å—Ç (–æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≤–∏–¥–µ–æ), –ø–æ—Ç–æ–º —Ñ–æ—Ç–æ.");
//   }

//   const photo = ctx.message.photo.pop();                // —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ –ø–æ —Ä–∞–∑–º–µ—Ä—É
//   const fileLink = await ctx.telegram.getFileLink(photo.file_id);
//   const filePath = path.join(TMP_DIR, `${photo.file_id}.jpg`);

//   try {
//     await downloadFile(fileLink.href, filePath);
//     await ctx.reply("–ì–µ–Ω–µ—Ä–∏—Ä—É—é –≤–∏–¥–µ–æ, –ø–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ‚Ä¶");

//     const videoUrl = await generateVideo(filePath, prompt);
//     await ctx.replyWithVideo({ url: videoUrl });
//   } catch (err) {
//     console.error(err);
//     await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ üòî");
//   } finally {
//     if (fs.existsSync(filePath)) fs.unlinkSync(filePath); // —á–∏—Å—Ç–∏–º tmp
//     userPrompts.delete(ctx.chat.id);
//   }
// });

// // ---------------------------------------------------------------------------
// // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª –ø–æ—Ç–æ–∫–æ–º —á–µ—Ä–µ–∑ axios
// async function downloadFile(url, dest) {
//   const response = await axios.get(url, { responseType: "stream" });
//   const writer = fs.createWriteStream(dest);
//   return new Promise((resolve, reject) => {
//     response.data.pipe(writer);
//     writer.on("finish", resolve);
//     writer.on("error", reject);
//   });
// }

// // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ Runway SDK
// async function generateVideo(imagePath, prompt) {
//   const dataUri = makeDataURI(imagePath);
//   const task = await runway.imageToVideo
//     .create({
//       model: "gen4_turbo",      // –ª–∏–±–æ gen-2/gen-3
//       promptImage: dataUri,      // < 5 –ú–ë base64
//       promptText: prompt,
//       ratio: "1280:720",
//       duration: 5,
//     })
//     .waitForTaskOutput();        // –∂–¥—ë–º SUCCEEDED

//   return task.output[0];         // —Å—Å—ã–ª–∫–∞ –Ω–∞ .mp4
// }

// // –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª –∏ –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –≤ Data URI
// function makeDataURI(filePath) {
//   const mime = "image/jpeg"; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ .jpg
//   const b64 = fs.readFileSync(filePath).toString("base64");
//   return `data:${mime};base64,${b64}`;
// }
// const DOMAIN = 'https://videomaker-pwn2.onrender.com'; 
// const TOKEN = '8049374841:AAE88n9H8oa4X0phtItDDM1OXEysFxKfOuA'; 

// // ---------------------------------------------------------------------------
// console.log("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –ù–∞–∂–º–∏ Ctrl-C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏.");
// bot.launch({
//   webhook: {
//     domain: DOMAIN,
//     port:  3000, 
//     hookPath: `/${TOKEN}`
//   }
// });
// // –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –≤—ã–∫–ª—é—á–µ–Ω–∏–µ
// process.once("SIGINT", () => bot.stop("SIGINT"));
// process.once("SIGTERM", () => bot.stop("SIGTERM"));


import { Telegraf } from "telegraf";
import RunwayML, { TaskFailedError, APIError } from "@runwayml/sdk";
import axios from "axios";
import fs from "fs";
import path from "path";
import sharp from "sharp";
import sizeOf from "image-size";
import dotenv from "dotenv";

dotenv.config();

const BOT_TOKEN = process.env.BOT_TOKEN;
const RUNWAY_API_KEY = process.env.RUNWAY_API_KEY;
const RUNWAY_VERSION = "2024-11-06";
const TMP_DIR = path.resolve("./images");

if (!fs.existsSync(TMP_DIR)) fs.mkdirSync(TMP_DIR);

const bot = new Telegraf(BOT_TOKEN);

const runway = new RunwayML({
  apiKey: RUNWAY_API_KEY,
  headers: { "X-Runway-Version": RUNWAY_VERSION },
});

const userPrompts = new Map();

bot.on("text", async (ctx) => {
  userPrompts.set(ctx.chat.id, ctx.message.text);
  await ctx.reply("–¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –≤–∏–¥–µ–æ.");
});

bot.on("photo", async (ctx) => {
  const prompt = userPrompts.get(ctx.chat.id);
  if (!prompt) {
    return ctx.reply("–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å —Ç–µ–∫—Å—Ç-–æ–ø–∏—Å–∞–Ω–∏–µ, –ø–æ—Ç–æ–º —Ñ–æ—Ç–æ.");
  }

  const photo = ctx.message.photo.pop();
  const fileLink = await ctx.telegram.getFileLink(photo.file_id);
  const originalPath = path.join(TMP_DIR, `${photo.file_id}_orig.jpg`);
  const resizedPath = path.join(TMP_DIR, `${photo.file_id}_resized.jpg`);

  try {
    await downloadFile(fileLink.href, originalPath);
    await resizeImage(originalPath, resizedPath);
    const ratio = getAutoRatio(resizedPath);

    await ctx.reply("–ì–µ–Ω–µ—Ä–∏—Ä—É—é –≤–∏–¥–µ–æ, –ø–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ‚Ä¶");

    const videoUrl = await generateVideo(resizedPath, prompt, ratio);
    await ctx.replyWithVideo({ url: videoUrl });
  } catch (err) {
    console.error("‚ùå –û—à–∏–±–∫–∞:", err);

    if (err.message?.includes("Runway –Ω–µ —Å–º–æ–≥")) {
      await ctx.reply("‚ö†Ô∏è Runway –Ω–µ —Å–º–æ–≥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–ª–∏ —Ñ–æ—Ç–æ.");
    } else if (err instanceof APIError && err.body?.error?.includes("ratio")) {
      await ctx.reply("‚ö†Ô∏è –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ. –û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –¥—Ä—É–≥–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞.");
    } else {
      await ctx.reply("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ üòî");
    }
  } finally {
    [originalPath, resizedPath].forEach((p) => fs.existsSync(p) && fs.unlinkSync(p));
    userPrompts.delete(ctx.chat.id);
  }
});

// üß† –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ/–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ —Ñ–æ—Ç–æ
function getAutoRatio(imagePath) {
  const { width, height } = sizeOf(imagePath);
  return width > height ? "1280:768" : "768:1280";
}

// –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–æ—Ç–æ
async function downloadFile(url, dest) {
  const response = await axios.get(url, { responseType: "stream" });
  const writer = fs.createWriteStream(dest);
  return new Promise((resolve, reject) => {
    response.data.pipe(writer);
    writer.on("finish", resolve);
    writer.on("error", reject);
  });
}

// –°–∂–∞—Ç–∏–µ —Ñ–æ—Ç–æ
async function resizeImage(inputPath, outputPath) {
  return sharp(inputPath)
    .resize({ width: 1024 })
    .jpeg({ quality: 80 })
    .toFile(outputPath);
}

// –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –≤ base64
function makeDataURI(filePath) {
  const mime = "image/jpeg";
  const b64 = fs.readFileSync(filePath).toString("base64");
  return `data:${mime};base64,${b64}`;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ Runway
async function generateVideo(imagePath, prompt, ratio) {
  const dataUri = makeDataURI(imagePath);

  try {
    const task = await runway.imageToVideo
      .create({
        model: "gen4_turbo",
        promptImage: dataUri,
        promptText: prompt,
        ratio,
        duration: 5,
      })
      .waitForTaskOutput();

    return task.output[0];
  } catch (err) {
    if (err instanceof TaskFailedError) {
      const details = err.taskDetails;
      console.error("‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:", details);

      if (details.failureCode === "INTERNAL.BAD_OUTPUT.CODE01") {
        throw new Error("Runway –Ω–µ —Å–º–æ–≥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–ª–∏ —Ñ–æ—Ç–æ.");
      }

      throw new Error("–û—à–∏–±–∫–∞ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –º–æ–¥–µ–ª–∏: " + details.failure);
    } else {
      throw err;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ webhook ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DOMAIN = 'https://videomaker-pwn2.onrender.com';
const TOKEN = BOT_TOKEN;

bot.launch({
  webhook: {
    domain: DOMAIN,
    port: 3000,
    hookPath: `/${TOKEN}`,
  },
});

console.log("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –ù–∞–∂–º–∏ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏");

process.once("SIGINT", () => bot.stop("SIGINT"));
process.once("SIGTERM", () => bot.stop("SIGTERM"));
